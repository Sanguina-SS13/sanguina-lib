const std = @import("std");
const def = @import("src/defines.zig");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const lib = b.addSharedLibrary(.{
        .name = "san",
        .root_source_file = b.path("src/root.zig"),
        .target = target,
        .optimize = optimize,
    });
    b.installArtifact(lib);

    const byondapi = b.addModule(
        "byondapi",
        std.Build.Module.CreateOptions{
            .root_source_file = b.path("src/byondapi/_byondapi.zig"),
            .target = target,
            .optimize = optimize,
        },
    );
    const globals = b.addModule(
        "globals",
        std.Build.Module.CreateOptions{
            .root_source_file = b.path("src/globals/_globals.zig"),
            .target = target,
            .optimize = optimize,
        },
    );
    byondapi.addImport("globals", globals);
    globals.addImport("byondapi", byondapi);

    lib.root_module.addImport("byondapi", byondapi);
    lib.root_module.addImport("globals", globals);

    const unit_tests = b.addTest(.{
        .root_source_file = b.path("src/root.zig"),
    });
    unit_tests.root_module.addImport("byondapi", byondapi);
    unit_tests.root_module.addImport("globals", byondapi);

    const run_unit_tests = b.addRunArtifact(unit_tests);

    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_unit_tests.step);
    test_step.dependOn(&lib.step);
}

/// Generates a `generated_files.zig` file that contains pairs of valid map files
fn generatePrecomp(b: *std.Build) void {
    // Open the directory
    var dir = std.fs.cwd().openDir("templates", .{ .iterate = true }) catch unreachable;
    defer dir.close();

    var json_files = std.StringHashMap(void).init(b.allocator);
    var dmm_files = std.StringHashMap(void).init(b.allocator);
    defer json_files.deinit();
    defer dmm_files.deinit();

    // Iterate through directory entries
    var iterator = dir.iterate();
    while (iterator.next() catch unreachable) |entry| {
        if (entry.kind == .file) {
            if (std.mem.endsWith(u8, entry.name, ".json")) {
                json_files.put(entry.name[0 .. entry.name.len - 5], {}) catch unreachable;
            } else if (std.mem.endsWith(u8, entry.name, ".dmm")) {
                dmm_files.put(entry.name[0 .. entry.name.len - 4], {}) catch unreachable;
            }
        }
    }

    // Check for missing pairs
    var json_iter = json_files.iterator();
    var missing = false;
    while (json_iter.next()) |pair| {
        if (!dmm_files.contains(pair.key_ptr.*)) {
            std.debug.print("ERROR: Missing .dmm file for {s}.json\n", .{pair.key_ptr.*});
            missing = true;
        }
    }
    var dmm_iter = dmm_files.iterator();
    while (dmm_iter.next()) |pair| {
        if (!json_files.contains(pair.key_ptr.*)) {
            std.debug.print("ERROR: Missing .json file for {s}.dmm\n", .{pair.key_ptr.*});
            missing = true;
        }
    }
    if (missing)
        @panic("");

    var output_file_content = std.ArrayList(u8).init(b.allocator);
    var writer = output_file_content.writer();

    writer.writeAll(
        \\/////////////////////////////////////////////////////////////////////////////////
        \\// THIS FILE IS AUTOGENERATED. NONE OF THE CHANGES WILL PERSIST. DONT BE DUMB. //
        \\/////////////////////////////////////////////////////////////////////////////////
        \\
        \\pub const FILES = []struct { filename: []const u8, dmm: []const u8, json: []const u8 }{
    ) catch unreachable;

    dmm_iter = dmm_files.iterator();
    json_iter = json_files.iterator();
    while (true) {
        const dmm = dmm_iter.next() orelse break;
        const json = json_iter.next().?;

        writer.print("    .{{ .json = @embedFile(\"{s}\"), .dmm = @embedFile(\"{s}\") }},\n", .{ json.key_ptr.*, dmm.key_ptr.* }) catch unreachable;
    }
    writer.writeAll("};") catch unreachable;

    _ = std.fs.cwd().writeFile(.{ .sub_path = "src/map_gen//_compgen_out.zig", .data = output_file_content.items }) catch unreachable;

    //load the config
    //var map_templates = std.StringHashMap(def.template_data).init(b.allocator);
    //defer map_templates.deinit();
    //
    //json_iter = json_files.iterator();
    //while (json_iter.next()) |pair| {
    //    const file = try std.fs.cwd().openFile(pair.key_ptr.*, .{});
    //    defer file.close();
    //
    //    const contents = file.readToEndAlloc(b.allocator, std.math.maxInt(usize));
    //    defer b.allocator.free(contents);
    //
    //    const parsed = std.json.parseFromSlice(std.json.Value, b.allocator, contents, .{}) catch |err| {
    //        @panic(err);
    //    };
    //
    //    // ok, actual reading time
    //    const id = parsed.value.object.get("id") orelse {
    //        std.debug.print("ERROR: Missing .json entry for {s} - [id]\n", .{pair.key_ptr.*});
    //        missing = true;
    //    };
    //    const always_place = if (parsed.value.object.get("always_place")) |value| value.bool else false;
    //    const placement_weight = if (parsed.value.object.get("placement_weight")) |value| value.integer else 0;
    //    const cost = if (parsed.value.object.get("cost")) |value| value.integer else 0;
    //    const allow_duplicates = if (parsed.value.object.get("allow_duplicates")) |value| value.bool else true;
    //    if (placement_weight != 0) {
    //        std.debug.print("WARNING: Redundant .json [placement_weight] entry set for {s} - [always_place] is set to true!", .{pair.key_ptr.*});
    //    }
    //    if (cost != 0) {
    //        std.debug.print("WARNING: Redundant .json [cost] entry set for {s} - [always_place] is set to true!", .{pair.key_ptr.*});
    //    }
    //
    //    if (map_templates.get(id)) {
    //        std.debug.print("ERROR: Duplicate .json [id] entry for {s}!", .{pair.key_ptr.*});
    //        missing = true;
    //        continue;
    //    }
    //
    //    map_templates.putNoClobber(id, def.template_data{
    //        .map_config = .{
    //            .allow_duplicates = allow_duplicates,
    //            .always_place = always_place,
    //            .cost = cost,
    //            .placement_weight = placement_weight,
    //        },
    //        .map_data = undefined,
    //    });
    //}
    //if (missing)
    //    @panic("");
    //
    ////load the map data
    //var imported_areas = std.StringHashMap(bool).init(b.allocator);
    //var imported_turfs = std.StringHashMap(bool).init(b.allocator);
    //var imported_movables = std.StringHashMap(bool).init(b.allocator);
    //defer imported_areas.deinit();
    //defer imported_turfs.deinit();
    //defer imported_movables.deinit();
    //
    //// Generate Zig code
    //var output_file_content = std.ArrayList(u8).init(b.allocator);
    //defer output_file_content.deinit();
    //
    //// predetermined shit to slap on top
    //const _AREA = struct {
    //    const WASTES = "/area/wilderness/wastes";
    //    const MAGMA_SWAMP = "/area/wilderness/magma_swamp";
    //    const FUNGUS_FOREST = "/area/wilderness/fungus_forest";
    //    const LEGION = "/area/wilderness/legion";
    //};
    //
    //const _TURF = struct {
    //    const BASALT = "/turf/open/basalt";
    //    const ROCK = "/turf/closed/mineral";
    //};
    //
    ////ok lets write
    //var writer = output_file_content.writer();
    //try writer.writeAll("/////////////////////////////////////////////////////////////////////////////////\n");
    //try writer.writeAll("// THIS FILE IS AUTOGENERATED. NONE OF THE CHANGES WILL PERSIST. DONT BE DUMB. //\n");
    //try writer.writeAll("/////////////////////////////////////////////////////////////////////////////////\n");
    //try writer.writeAll("const std = @import(\"std\")\n");
    //try writer.writeAll("const def = @import(\"defines.zig\")\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub const AREA = enum{\n");
    //inline for (std.meta.fieldNames(_AREA)) |name| {
    //    try writer.print("    {s},\n", .{name});
    //}
    //inline for (0..imported_areas.items.len) |i| {
    //    try writer.print("    _GEN_AREA_{d},\n", .{i + 1});
    //}
    //try writer.writeAll("};\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub const TURF = enum{\n");
    //
    //inline for (std.meta.fieldNames(_TURF)) |name| {
    //    try writer.print("    {s},\n", .{name});
    //}
    //inline for (0..imported_turfs.items.len) |i| {
    //    try writer.print("    _GEN_TURF_{d},\n", .{i + 1});
    //}
    //try writer.writeAll("};\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub const MOVABLE = enum{\n");
    //inline for (0..imported_movables.items.len) |i| {
    //    try writer.print("    _GEN_MOVABLE_{d},\n", .{i + 1});
    //}
    //try writer.writeAll("};\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub fn area2path(area: AREA) []const u8 {\n");
    //inline for (std.meta.fields(_AREA)) |pair| {
    //    try writer.print("    .{s} => \"{s}\",\n", .{ pair.name, pair.type });
    //}
    //inline for (imported_areas.items, 0..) |path, i| {
    //    try writer.print("    ._GEN_AREA_{d} => \"{s}\",\n", .{ i + 1, path });
    //}
    //try writer.writeAll("}\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub fn turf2path(turf: TURF) []const u8 {\n");
    //inline for (std.meta.fields(_TURF)) |pair| {
    //    try writer.print("    .{s} => \"{s}\",\n", .{ pair.name, pair.type });
    //}
    //inline for (imported_turfs.items, 0..) |path, i| {
    //    try writer.print("    ._GEN_TURF_{d} => \"{s}\",\n", .{ i + 1, path });
    //}
    //try writer.writeAll("}\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub fn movable2path(movable: MOVABLE) []const u8 {\n");
    //inline for (imported_movables.items, 0..) |path, i| {
    //    try writer.print("    ._GEN_MOVABLE_{d} => \"{s}\",\n", .{ i + 1, path });
    //}
    //try writer.writeAll("};\n");
    //try writer.writeAll("\n");
    //try writer.writeAll("pub const structure_lookup = std.StaticStringMap(template_data).initComptime(\n");
    //var template_iter = map_templates.iterator();
    //while (template_iter.next()) |pair| {
    //    try writer.print(
    //        \\.{{ {s}, def.template_data{{
    //        \\    .map_config = {
    //        \\        .always_place: bool = {s},
    //        \\        .placement_weight = {d},
    //        \\        .cost = {d},
    //        \\        .allow_duplicates = {s},
    //        \\        //.ruin_type:
    //        \\    },
    //        \\    .map_data = [{s}],
    //        \\}}}},
    //    , .{
    //        pair.key_ptr.*, //id
    //        if (pair.value_ptr.map_config.always_place) "true" else "false", //always_place
    //        pair.value_ptr.map_config.placement_weight,
    //        pair.value_ptr.map_config.cost,
    //        if (pair.value_ptr.map_config.allow_duplicates) "true" else "false",
    //        //pair.value_ptr.map_config.ruin_type,
    //        pair.value_ptr.map_data,
    //    });
    //}
    //try writer.writeAll(");");
    //// Write to file
}
